   1               		.file	"ServoController.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	CreateList
  12               	CreateList:
  13               	.LFB7:
  14               		.file 1 "ServoController.c"
   1:ServoController.c **** /*
   2:ServoController.c ****  * Servo_Driver.c
   3:ServoController.c ****  *
   4:ServoController.c ****  * Created: 2/22/2015 1:30:51 AM
   5:ServoController.c ****  *  Author: RahulSingh
   6:ServoController.c ****  */ 
   7:ServoController.c **** //*************************************************************************************************
   8:ServoController.c **** //						DEFINES						       //
   9:ServoController.c **** //*************************************************************************************************
  10:ServoController.c **** #define F_CPU 				16000000UL
  11:ServoController.c **** #define setbit(x,y) 		x |=(1<<y)
  12:ServoController.c **** #define clearbit(x,y)  		x &=~(1<<y)
  13:ServoController.c **** #define togglebit(x,y) 		x ^=(1<<y)
  14:ServoController.c **** #define BAUDRATE			9600
  15:ServoController.c **** #define UBRR_VAL			103
  16:ServoController.c **** #define END_OF_SIGNAL		13		//ENTER KEY
  17:ServoController.c **** 
  18:ServoController.c **** #define ICR_VAL 			1100
  19:ServoController.c **** #define SERVO_NUMBER		8
  20:ServoController.c **** #define SERVO_MIN_ANGLE 	0
  21:ServoController.c **** 
  22:ServoController.c **** #define SERVO_MAX_ANGLE 	180
  23:ServoController.c **** #define ICR1_BASE_VALUE 	1100	//it is base of minimun high time of pulse typically it is 1.1 ms
  24:ServoController.c **** #define ICR1_TOP_VALUE		3999	//20 ms PULSE i.e. 50Hz frequency
  25:ServoController.c **** #define FACTOR 				22.22	//It is evaluated as 4000/180 degree
  26:ServoController.c **** 
  27:ServoController.c **** //#define ANGLE_SCALE_FACTOR 	22.22	//It is evaluated as 4000/180 degree => 22.222222
  28:ServoController.c **** 
  29:ServoController.c **** //*************************************************************************************************
  30:ServoController.c **** //										 INCLUDED LIBRARRY		       							       //
  31:ServoController.c **** //*************************************************************************************************
  32:ServoController.c **** #include <avr/io.h>
  33:ServoController.c **** #include <avr/interrupt.h>
  34:ServoController.c **** #include <util/delay.h>
  35:ServoController.c **** #include <stdio.h>
  36:ServoController.c **** #include <stdlib.h> 
  37:ServoController.c **** #include <math.h>
  38:ServoController.c **** 
  39:ServoController.c **** 
  40:ServoController.c **** //*************************************************************************************************
  41:ServoController.c **** //	   										GLOBAL VARIBLES										       //
  42:ServoController.c **** //*************************************************************************************************
  43:ServoController.c **** struct structServo{
  44:ServoController.c **** 	uint16_t angle;
  45:ServoController.c **** 	uint16_t number;
  46:ServoController.c **** 	struct structServo *node;
  47:ServoController.c **** };
  48:ServoController.c **** 
  49:ServoController.c **** typedef struct structServo servoList;
  50:ServoController.c **** servoList *servoHead;					//To store the head pointer
  51:ServoController.c **** servoList *tempServoHead;
  52:ServoController.c **** 
  53:ServoController.c **** servoList *servoSwitch;
  54:ServoController.c **** servoList *servoSwitchDup;
  55:ServoController.c **** servoList **servoSwitchPtrDup;
  56:ServoController.c **** servoList **servoSwitchPtr;
  57:ServoController.c **** 
  58:ServoController.c **** servoList **servoSwitchListPtr;
  59:ServoController.c **** uint16_t servoStartAngle[8]={25,50,75,100,125,150,160,179};
  60:ServoController.c **** 
  61:ServoController.c **** int flag1=1;
  62:ServoController.c **** int count=0;										//Counter for servo timer ISR
  63:ServoController.c **** 
  64:ServoController.c **** char tempData[6]={0,0,0,0,0,0};
  65:ServoController.c **** char *tempDataPtr;
  66:ServoController.c **** uint16_t baudRate=103;								//=((F_CPU/(16*BAUDRATE))-1);
  67:ServoController.c **** int arrangeSignalFlag=0;
  68:ServoController.c **** 
  69:ServoController.c **** //*************************************************************************************************
  70:ServoController.c **** //	  									  FUNCTION PROTOTYPES	   									   //
  71:ServoController.c **** //*************************************************************************************************
  72:ServoController.c **** void USARTInit();
  73:ServoController.c **** servoList* ArrangeAngle(servoList *servoAngle, servoList *servoNodeHead,int num);
  74:ServoController.c **** servoList* CreateList();
  75:ServoController.c **** void PrepareAddToList(char *start);
  76:ServoController.c **** uint16_t StringToInt(char *dataStart);
  77:ServoController.c **** void SendInteger(uint16_t num);
  78:ServoController.c **** servoList* SendList(servoList* head);
  79:ServoController.c **** void ServoPortInit();
  80:ServoController.c **** void TimerInit();
  81:ServoController.c **** 
  82:ServoController.c **** //*************************************************************************************************
  83:ServoController.c **** //	      										 FUNCTIONS					 	   				       //
  84:ServoController.c **** //*************************************************************************************************
  85:ServoController.c **** 
  86:ServoController.c **** servoList* CreateList()
  87:ServoController.c **** {
  15               		.loc 1 87 0
  16               		.cfi_startproc
  17 0000 CF92      		push r12
  18               	.LCFI0:
  19               		.cfi_def_cfa_offset 3
  20               		.cfi_offset 12, -2
  21 0002 DF92      		push r13
  22               	.LCFI1:
  23               		.cfi_def_cfa_offset 4
  24               		.cfi_offset 13, -3
  25 0004 EF92      		push r14
  26               	.LCFI2:
  27               		.cfi_def_cfa_offset 5
  28               		.cfi_offset 14, -4
  29 0006 FF92      		push r15
  30               	.LCFI3:
  31               		.cfi_def_cfa_offset 6
  32               		.cfi_offset 15, -5
  33 0008 0F93      		push r16
  34               	.LCFI4:
  35               		.cfi_def_cfa_offset 7
  36               		.cfi_offset 16, -6
  37 000a 1F93      		push r17
  38               	.LCFI5:
  39               		.cfi_def_cfa_offset 8
  40               		.cfi_offset 17, -7
  41 000c CF93      		push r28
  42               	.LCFI6:
  43               		.cfi_def_cfa_offset 9
  44               		.cfi_offset 28, -8
  45 000e DF93      		push r29
  46               	.LCFI7:
  47               		.cfi_def_cfa_offset 10
  48               		.cfi_offset 29, -9
  49               	/* prologue: function */
  50               	/* frame size = 0 */
  51               	/* stack size = 8 */
  52               	.L__stack_usage = 8
  53               	.LVL0:
  54 0010 80E0      		ldi r24,lo8(servoStartAngle)
  55 0012 C82E      		mov r12,r24
  56 0014 80E0      		ldi r24,hi8(servoStartAngle)
  57 0016 D82E      		mov r13,r24
  88:ServoController.c **** 	int i;
  89:ServoController.c **** 	servoList *head, *first, *temp = 0;
  58               		.loc 1 89 0
  59 0018 E12C      		mov r14,__zero_reg__
  60 001a F12C      		mov r15,__zero_reg__
  90:ServoController.c **** 	first = 0;
  61               		.loc 1 90 0
  62 001c 00E0      		ldi r16,0
  63 001e 10E0      		ldi r17,0
  91:ServoController.c **** 	for(i=0; i<8; i++){
  64               		.loc 1 91 0
  65 0020 C0E0      		ldi r28,0
  66 0022 D0E0      		ldi r29,0
  67               	.LVL1:
  68               	.L4:
  92:ServoController.c **** 		head  = (servoList*)malloc(sizeof(servoList));
  69               		.loc 1 92 0
  70 0024 86E0      		ldi r24,lo8(6)
  71 0026 90E0      		ldi r25,0
  72 0028 0E94 0000 		call malloc
  73               	.LVL2:
  74 002c FC01      		movw r30,r24
  75               	.LVL3:
  93:ServoController.c **** 		head->angle=servoStartAngle[i];
  76               		.loc 1 93 0
  77 002e D601      		movw r26,r12
  78 0030 8D91      		ld r24,X+
  79 0032 9D91      		ld r25,X+
  80               	.LVL4:
  81 0034 6D01      		movw r12,r26
  82 0036 9183      		std Z+1,r25
  83 0038 8083      		st Z,r24
  94:ServoController.c **** 		head->number=i+1;
  84               		.loc 1 94 0
  85 003a 2196      		adiw r28,1
  86               	.LVL5:
  87 003c D383      		std Z+3,r29
  88 003e C283      		std Z+2,r28
  95:ServoController.c **** 		if (first != 0){
  89               		.loc 1 95 0
  90 0040 0115      		cp r16,__zero_reg__
  91 0042 1105      		cpc r17,__zero_reg__
  92 0044 01F0      		breq .L5
  96:ServoController.c **** 			temp->node = head;
  93               		.loc 1 96 0
  94 0046 D701      		movw r26,r14
  95 0048 1596      		adiw r26,4+1
  96 004a FC93      		st X,r31
  97 004c EE93      		st -X,r30
  98 004e 1497      		sbiw r26,4
  99               	.LVL6:
 100 0050 00C0      		rjmp .L2
 101               	.LVL7:
 102               	.L5:
  92:ServoController.c **** 		head  = (servoList*)malloc(sizeof(servoList));
 103               		.loc 1 92 0
 104 0052 8F01      		movw r16,r30
 105               	.LVL8:
 106               	.L2:
  91:ServoController.c **** 	for(i=0; i<8; i++){
 107               		.loc 1 91 0 discriminator 1
 108 0054 C830      		cpi r28,8
 109 0056 D105      		cpc r29,__zero_reg__
 110 0058 01F0      		breq .L3
  92:ServoController.c **** 		head  = (servoList*)malloc(sizeof(servoList));
 111               		.loc 1 92 0
 112 005a 7F01      		movw r14,r30
 113 005c 00C0      		rjmp .L4
 114               	.L3:
  97:ServoController.c **** 			temp = head;
  98:ServoController.c **** 		}
  99:ServoController.c **** 		else
 100:ServoController.c **** 		first = temp = head;
 101:ServoController.c **** 	}
 102:ServoController.c **** 	temp->node = 0;
 115               		.loc 1 102 0
 116 005e 1582      		std Z+5,__zero_reg__
 117 0060 1482      		std Z+4,__zero_reg__
 118               	.LVL9:
 103:ServoController.c **** 	temp = first;
 104:ServoController.c **** 	return first;
 105:ServoController.c **** }
 119               		.loc 1 105 0
 120 0062 C801      		movw r24,r16
 121               	/* epilogue start */
 122 0064 DF91      		pop r29
 123 0066 CF91      		pop r28
 124               	.LVL10:
 125 0068 1F91      		pop r17
 126 006a 0F91      		pop r16
 127               	.LVL11:
 128 006c FF90      		pop r15
 129 006e EF90      		pop r14
 130 0070 DF90      		pop r13
 131 0072 CF90      		pop r12
 132 0074 0895      		ret
 133               		.cfi_endproc
 134               	.LFE7:
 136               	.global	ArrangeAngle
 138               	ArrangeAngle:
 139               	.LFB8:
 106:ServoController.c **** 
 107:ServoController.c **** servoList* ArrangeAngle(servoList *servoAngle,servoList *nodeHead,int num)
 108:ServoController.c **** {
 140               		.loc 1 108 0
 141               		.cfi_startproc
 142               	.LVL12:
 143 0076 AF92      		push r10
 144               	.LCFI8:
 145               		.cfi_def_cfa_offset 3
 146               		.cfi_offset 10, -2
 147 0078 BF92      		push r11
 148               	.LCFI9:
 149               		.cfi_def_cfa_offset 4
 150               		.cfi_offset 11, -3
 151 007a CF92      		push r12
 152               	.LCFI10:
 153               		.cfi_def_cfa_offset 5
 154               		.cfi_offset 12, -4
 155 007c DF92      		push r13
 156               	.LCFI11:
 157               		.cfi_def_cfa_offset 6
 158               		.cfi_offset 13, -5
 159 007e EF92      		push r14
 160               	.LCFI12:
 161               		.cfi_def_cfa_offset 7
 162               		.cfi_offset 14, -6
 163 0080 FF92      		push r15
 164               	.LCFI13:
 165               		.cfi_def_cfa_offset 8
 166               		.cfi_offset 15, -7
 167 0082 0F93      		push r16
 168               	.LCFI14:
 169               		.cfi_def_cfa_offset 9
 170               		.cfi_offset 16, -8
 171 0084 1F93      		push r17
 172               	.LCFI15:
 173               		.cfi_def_cfa_offset 10
 174               		.cfi_offset 17, -9
 175 0086 CF93      		push r28
 176               	.LCFI16:
 177               		.cfi_def_cfa_offset 11
 178               		.cfi_offset 28, -10
 179 0088 DF93      		push r29
 180               	.LCFI17:
 181               		.cfi_def_cfa_offset 12
 182               		.cfi_offset 29, -11
 183               	/* prologue: function */
 184               	/* frame size = 0 */
 185               	/* stack size = 10 */
 186               	.L__stack_usage = 10
 187 008a DC01      		movw r26,r24
 188 008c FB01      		movw r30,r22
 109:ServoController.c **** 	if(servoAngle->angle<=180 && servoAngle->number<=8){
 189               		.loc 1 109 0
 190 008e 0D91      		ld r16,X+
 191 0090 1C91      		ld r17,X
 192 0092 1197      		sbiw r26,1
 193 0094 053B      		cpi r16,-75
 194 0096 1105      		cpc r17,__zero_reg__
 195 0098 00F0      		brlo .+2
 196 009a 00C0      		rjmp .L26
 197               		.loc 1 109 0 is_stmt 0 discriminator 1
 198 009c 1296      		adiw r26,2
 199 009e ED90      		ld r14,X+
 200 00a0 FC90      		ld r15,X
 201 00a2 1397      		sbiw r26,2+1
 202 00a4 89E0      		ldi r24,9
 203 00a6 E816      		cp r14,r24
 204 00a8 F104      		cpc r15,__zero_reg__
 205               	.LVL13:
 206 00aa 00F0      		brlo .+2
 207 00ac 00C0      		rjmp .L26
 208               	.LVL14:
 209               	.LBB6:
 110:ServoController.c **** 		servoList *servoNode;
 111:ServoController.c **** 		servoList *servoPreviousNode;
 112:ServoController.c **** 		servoNode = nodeHead;
 113:ServoController.c **** 		servoPreviousNode=nodeHead;						//CHANGED
 114:ServoController.c **** 		int flagAngle=0;
 115:ServoController.c **** 		int flagNumber=0;
 116:ServoController.c **** 		if(servoAngle->number == nodeHead->number){
 210               		.loc 1 116 0 is_stmt 1
 211 00ae 8281      		ldd r24,Z+2
 212 00b0 9381      		ldd r25,Z+3
 213 00b2 E816      		cp r14,r24
 214 00b4 F906      		cpc r15,r25
 215 00b6 01F4      		brne .L20
 117:ServoController.c **** //Check the difference between *servoSwitchPtr=servoNodeHead and servoSwitchPtr=&servoNodeHead;
 118:ServoController.c **** //It does not work with servoSwitchPtr=&nodeHead;
 119:ServoController.c **** 		if(num==1)
 216               		.loc 1 119 0
 217 00b8 4130      		cpi r20,1
 218 00ba 5105      		cpc r21,__zero_reg__
 219 00bc 01F4      		brne .L10
 120:ServoController.c **** 			*servoSwitchPtr=nodeHead;
 220               		.loc 1 120 0
 221 00be C091 0000 		lds r28,servoSwitchPtr
 222 00c2 D091 0000 		lds r29,servoSwitchPtr+1
 223 00c6 00C0      		rjmp .L31
 224               	.L10:
 121:ServoController.c **** 		else
 122:ServoController.c **** 			*servoSwitchPtrDup=nodeHead;
 225               		.loc 1 122 0
 226 00c8 C091 0000 		lds r28,servoSwitchPtrDup
 227 00cc D091 0000 		lds r29,servoSwitchPtrDup+1
 228               	.L31:
 229 00d0 F983      		std Y+1,r31
 230 00d2 E883      		st Y,r30
 123:ServoController.c **** 			nodeHead=servoNode->node;
 231               		.loc 1 123 0
 232 00d4 A480      		ldd r10,Z+4
 233 00d6 B580      		ldd r11,Z+5
 234               	.LVL15:
 124:ServoController.c **** 			flagNumber=1;
 235               		.loc 1 124 0
 236 00d8 61E0      		ldi r22,lo8(1)
 237 00da 70E0      		ldi r23,0
 238               	.LVL16:
 239 00dc 00C0      		rjmp .L9
 240               	.LVL17:
 241               	.L20:
 242 00de 5B01      		movw r10,r22
 115:ServoController.c **** 		int flagNumber=0;
 243               		.loc 1 115 0
 244 00e0 60E0      		ldi r22,0
 245 00e2 70E0      		ldi r23,0
 246               	.LVL18:
 247               	.L9:
 125:ServoController.c **** 		}
 126:ServoController.c **** 		if(servoAngle->angle <= nodeHead->angle){
 248               		.loc 1 126 0
 249 00e4 E501      		movw r28,r10
 250 00e6 8881      		ld r24,Y
 251 00e8 9981      		ldd r25,Y+1
 252 00ea 8017      		cp r24,r16
 253 00ec 9107      		cpc r25,r17
 254 00ee 00F0      		brlo .L21
 127:ServoController.c **** 			servoAngle->node=nodeHead;
 255               		.loc 1 127 0
 256 00f0 1596      		adiw r26,4+1
 257 00f2 BC92      		st X,r11
 258 00f4 AE92      		st -X,r10
 259 00f6 1497      		sbiw r26,4
 260               	.LVL19:
 128:ServoController.c **** 			nodeHead=servoAngle;
 129:ServoController.c **** 			servoPreviousNode=servoAngle;
 261               		.loc 1 129 0
 262 00f8 CD01      		movw r24,r26
 128:ServoController.c **** 			nodeHead=servoAngle;
 263               		.loc 1 128 0
 264 00fa 5D01      		movw r10,r26
 130:ServoController.c **** 			flagAngle=1;
 265               		.loc 1 130 0
 266 00fc 21E0      		ldi r18,lo8(1)
 267 00fe 30E0      		ldi r19,0
 268 0100 00C0      		rjmp .L13
 269               	.LVL20:
 270               	.L21:
 113:ServoController.c **** 		servoPreviousNode=nodeHead;						//CHANGED
 271               		.loc 1 113 0
 272 0102 CF01      		movw r24,r30
 114:ServoController.c **** 		int flagAngle=0;
 273               		.loc 1 114 0
 274 0104 20E0      		ldi r18,0
 275 0106 30E0      		ldi r19,0
 276 0108 00C0      		rjmp .L13
 277               	.LVL21:
 278               	.L19:
 131:ServoController.c **** 		} 
 132:ServoController.c **** 		while(servoNode !=NULL){
 133:ServoController.c **** 			if((servoAngle->angle <= servoNode->angle)&& flagAngle !=1){
 279               		.loc 1 133 0
 280 010a C080      		ld r12,Z
 281 010c D180      		ldd r13,Z+1
 282 010e C016      		cp r12,r16
 283 0110 D106      		cpc r13,r17
 284 0112 00F4      		brsh .L33
 285               	.LVL22:
 286               	.L14:
 134:ServoController.c **** 				servoPreviousNode->node=servoAngle;
 135:ServoController.c **** 				servoAngle->node=servoNode;
 136:ServoController.c **** 				servoPreviousNode=servoAngle;
 137:ServoController.c **** 				flagAngle=1;
 138:ServoController.c **** 			}
 139:ServoController.c **** 			if((servoAngle->number==servoNode->number)&& flagNumber!=1){
 287               		.loc 1 139 0
 288 0114 C280      		ldd r12,Z+2
 289 0116 D380      		ldd r13,Z+3
 290 0118 EC14      		cp r14,r12
 291 011a FD04      		cpc r15,r13
 292 011c 01F0      		breq .L34
 293 011e CF01      		movw r24,r30
 294               	.LVL23:
 295               	.L15:
 140:ServoController.c **** 				if(num==1)
 141:ServoController.c **** 					*servoSwitchPtr=servoNode;
 142:ServoController.c **** 				else
 143:ServoController.c **** 					*servoSwitchPtrDup=servoNode;
 144:ServoController.c **** 				servoPreviousNode->node=servoNode->node;
 145:ServoController.c **** 				flagNumber=1;
 146:ServoController.c **** 			}
 147:ServoController.c **** 			servoPreviousNode=(servoAngle->number==servoNode->number)? servoPreviousNode:servoNode;
 148:ServoController.c **** 			servoNode=servoNode->node;		
 296               		.loc 1 148 0 discriminator 3
 297 0120 0480      		ldd __tmp_reg__,Z+4
 298 0122 F581      		ldd r31,Z+5
 299 0124 E02D      		mov r30,__tmp_reg__
 300               	.LVL24:
 301               	.L13:
 132:ServoController.c **** 		while(servoNode !=NULL){
 302               		.loc 1 132 0 discriminator 1
 303 0126 3097      		sbiw r30,0
 304 0128 01F4      		brne .L19
 305 012a 00C0      		rjmp .L35
 306               	.L33:
 133:ServoController.c **** 			if((servoAngle->angle <= servoNode->angle)&& flagAngle !=1){
 307               		.loc 1 133 0 discriminator 1
 308 012c 2130      		cpi r18,1
 309 012e 3105      		cpc r19,__zero_reg__
 310 0130 01F0      		breq .L14
 134:ServoController.c **** 				servoPreviousNode->node=servoAngle;
 311               		.loc 1 134 0
 312 0132 EC01      		movw r28,r24
 313 0134 BD83      		std Y+5,r27
 314 0136 AC83      		std Y+4,r26
 135:ServoController.c **** 				servoAngle->node=servoNode;
 315               		.loc 1 135 0
 316 0138 1596      		adiw r26,4+1
 317 013a FC93      		st X,r31
 318 013c EE93      		st -X,r30
 319 013e 1497      		sbiw r26,4
 320               	.LVL25:
 136:ServoController.c **** 				servoPreviousNode=servoAngle;
 321               		.loc 1 136 0
 322 0140 CD01      		movw r24,r26
 137:ServoController.c **** 				flagAngle=1;
 323               		.loc 1 137 0
 324 0142 21E0      		ldi r18,lo8(1)
 325 0144 30E0      		ldi r19,0
 326 0146 00C0      		rjmp .L14
 327               	.LVL26:
 328               	.L34:
 139:ServoController.c **** 			if((servoAngle->number==servoNode->number)&& flagNumber!=1){
 329               		.loc 1 139 0 discriminator 1
 330 0148 6130      		cpi r22,1
 331 014a 7105      		cpc r23,__zero_reg__
 332 014c 01F0      		breq .L16
 140:ServoController.c **** 				if(num==1)
 333               		.loc 1 140 0
 334 014e 4130      		cpi r20,1
 335 0150 5105      		cpc r21,__zero_reg__
 336 0152 01F4      		brne .L17
 141:ServoController.c **** 					*servoSwitchPtr=servoNode;
 337               		.loc 1 141 0
 338 0154 6091 0000 		lds r22,servoSwitchPtr
 339 0158 7091 0000 		lds r23,servoSwitchPtr+1
 340               	.LVL27:
 341 015c 00C0      		rjmp .L32
 342               	.LVL28:
 343               	.L17:
 143:ServoController.c **** 					*servoSwitchPtrDup=servoNode;
 344               		.loc 1 143 0
 345 015e 6091 0000 		lds r22,servoSwitchPtrDup
 346 0162 7091 0000 		lds r23,servoSwitchPtrDup+1
 347               	.LVL29:
 348               	.L32:
 349 0166 EB01      		movw r28,r22
 350 0168 F983      		std Y+1,r31
 351 016a E883      		st Y,r30
 144:ServoController.c **** 				servoPreviousNode->node=servoNode->node;
 352               		.loc 1 144 0
 353 016c 6481      		ldd r22,Z+4
 354 016e 7581      		ldd r23,Z+5
 355 0170 EC01      		movw r28,r24
 356 0172 7D83      		std Y+5,r23
 357 0174 6C83      		std Y+4,r22
 358               	.LVL30:
 359 0176 00C0      		rjmp .L16
 360               	.LVL31:
 361               	.L35:
 149:ServoController.c **** 		}
 150:ServoController.c **** 		if(flagAngle==0){	
 362               		.loc 1 150 0
 363 0178 232B      		or r18,r19
 364 017a 01F4      		brne .L23
 151:ServoController.c **** 			servoPreviousNode->node=servoAngle;
 365               		.loc 1 151 0
 366 017c FC01      		movw r30,r24
 367               	.LVL32:
 368 017e B583      		std Z+5,r27
 369 0180 A483      		std Z+4,r26
 152:ServoController.c **** 			servoAngle->node=NULL;
 370               		.loc 1 152 0
 371 0182 1596      		adiw r26,4+1
 372 0184 1C92      		st X,__zero_reg__
 373 0186 1E92      		st -X,__zero_reg__
 374 0188 1497      		sbiw r26,4
 375               	.L23:
 153:ServoController.c **** 		}
 154:ServoController.c **** 		return nodeHead;
 376               		.loc 1 154 0
 377 018a F501      		movw r30,r10
 378 018c 00C0      		rjmp .L26
 379               	.LVL33:
 380               	.L16:
 137:ServoController.c **** 				flagAngle=1;
 381               		.loc 1 137 0
 382 018e 61E0      		ldi r22,lo8(1)
 383 0190 70E0      		ldi r23,0
 384 0192 00C0      		rjmp .L15
 385               	.LVL34:
 386               	.L26:
 387               	.LBE6:
 155:ServoController.c **** 	}
 156:ServoController.c **** 	else{
 157:ServoController.c **** 		return nodeHead;
 158:ServoController.c **** 	}		
 159:ServoController.c **** }
 388               		.loc 1 159 0
 389 0194 CF01      		movw r24,r30
 390               	/* epilogue start */
 391 0196 DF91      		pop r29
 392 0198 CF91      		pop r28
 393 019a 1F91      		pop r17
 394 019c 0F91      		pop r16
 395 019e FF90      		pop r15
 396 01a0 EF90      		pop r14
 397 01a2 DF90      		pop r13
 398 01a4 CF90      		pop r12
 399 01a6 BF90      		pop r11
 400 01a8 AF90      		pop r10
 401 01aa 0895      		ret
 402               		.cfi_endproc
 403               	.LFE8:
 405               	.global	SendInteger
 407               	SendInteger:
 408               	.LFB10:
 160:ServoController.c **** 
 161:ServoController.c **** void PrepareAddToList(char *start)
 162:ServoController.c **** {
 163:ServoController.c **** 	(*servoSwitchPtr)->number=(*start-48);
 164:ServoController.c **** 	(*servoSwitchPtr)->angle=StringToInt(start+1);
 165:ServoController.c **** 	(*servoSwitchPtrDup)->number=(*start-48);
 166:ServoController.c **** 	(*servoSwitchPtrDup)->angle=StringToInt(start+1);
 167:ServoController.c **** }
 168:ServoController.c **** 
 169:ServoController.c **** void SendInteger(uint16_t num)
 170:ServoController.c **** {
 409               		.loc 1 170 0
 410               		.cfi_startproc
 411               	.LVL35:
 412               	/* prologue: function */
 413               	/* frame size = 0 */
 414               	/* stack size = 0 */
 415               	.L__stack_usage = 0
 416               	.LBB7:
 417               	.LBB8:
 418               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 419               		.loc 2 164 0
 420 01ac EFE3      		ldi r30,lo8(-25537)
 421 01ae FCE9      		ldi r31,hi8(-25537)
 422 01b0 3197      		1: sbiw r30,1
 423 01b2 01F4      		brne 1b
 424 01b4 00C0      		rjmp .
 425 01b6 0000      		nop
 426               	.L38:
 427               	.LBE8:
 428               	.LBE7:
 171:ServoController.c **** 	_delay_ms(10);
 172:ServoController.c **** 	while(!(UCSRA && (1<<UDRE)));
 429               		.loc 1 172 0 discriminator 1
 430 01b8 9BB1      		in r25,0xb
 431 01ba 9923      		tst r25
 432 01bc 01F0      		breq .L38
 173:ServoController.c **** 	UDR=num;
 433               		.loc 1 173 0
 434 01be 8CB9      		out 0xc,r24
 435 01c0 0895      		ret
 436               		.cfi_endproc
 437               	.LFE10:
 439               	.global	StringToInt
 441               	StringToInt:
 442               	.LFB11:
 174:ServoController.c **** }
 175:ServoController.c **** 
 176:ServoController.c **** uint16_t StringToInt(char *dataStart)
 177:ServoController.c **** {
 443               		.loc 1 177 0
 444               		.cfi_startproc
 445               	.LVL36:
 446               	/* prologue: function */
 447               	/* frame size = 0 */
 448               	/* stack size = 0 */
 449               	.L__stack_usage = 0
 450 01c2 FC01      		movw r30,r24
 451               	.LVL37:
 178:ServoController.c **** 	uint16_t data=0;
 452               		.loc 1 178 0
 453 01c4 80E0      		ldi r24,0
 454 01c6 90E0      		ldi r25,0
 455               	.LVL38:
 179:ServoController.c **** 	while(*dataStart!=END_OF_SIGNAL){	//ASSIGN THE STOP BIT RECOGNITION
 180:ServoController.c **** 		data=data*10+(*dataStart-48);
 456               		.loc 1 180 0
 457 01c8 3AE0      		ldi r19,lo8(10)
 458               	.LVL39:
 459               	.L40:
 179:ServoController.c **** 	while(*dataStart!=END_OF_SIGNAL){	//ASSIGN THE STOP BIT RECOGNITION
 460               		.loc 1 179 0 discriminator 1
 461 01ca 2191      		ld r18,Z+
 462               	.LVL40:
 463 01cc 2D30      		cpi r18,lo8(13)
 464 01ce 01F0      		breq .L42
 465               		.loc 1 180 0
 466 01d0 AC01      		movw r20,r24
 467 01d2 349F      		mul r19,r20
 468 01d4 C001      		movw r24,r0
 469 01d6 359F      		mul r19,r21
 470 01d8 900D      		add r25,r0
 471 01da 1124      		clr __zero_reg__
 472               	.LVL41:
 473 01dc C097      		sbiw r24,48
 474 01de 820F      		add r24,r18
 475 01e0 911D      		adc r25,__zero_reg__
 476               	.LVL42:
 477 01e2 00C0      		rjmp .L40
 478               	.LVL43:
 479               	.L42:
 480               	/* epilogue start */
 181:ServoController.c **** 		dataStart++;
 182:ServoController.c **** 	}
 183:ServoController.c **** 	return data;
 184:ServoController.c **** }
 481               		.loc 1 184 0
 482 01e4 0895      		ret
 483               		.cfi_endproc
 484               	.LFE11:
 486               	.global	PrepareAddToList
 488               	PrepareAddToList:
 489               	.LFB9:
 162:ServoController.c **** {
 490               		.loc 1 162 0
 491               		.cfi_startproc
 492               	.LVL44:
 493 01e6 EF92      		push r14
 494               	.LCFI18:
 495               		.cfi_def_cfa_offset 3
 496               		.cfi_offset 14, -2
 497 01e8 FF92      		push r15
 498               	.LCFI19:
 499               		.cfi_def_cfa_offset 4
 500               		.cfi_offset 15, -3
 501 01ea 0F93      		push r16
 502               	.LCFI20:
 503               		.cfi_def_cfa_offset 5
 504               		.cfi_offset 16, -4
 505 01ec 1F93      		push r17
 506               	.LCFI21:
 507               		.cfi_def_cfa_offset 6
 508               		.cfi_offset 17, -5
 509 01ee CF93      		push r28
 510               	.LCFI22:
 511               		.cfi_def_cfa_offset 7
 512               		.cfi_offset 28, -6
 513 01f0 DF93      		push r29
 514               	.LCFI23:
 515               		.cfi_def_cfa_offset 8
 516               		.cfi_offset 29, -7
 517               	/* prologue: function */
 518               	/* frame size = 0 */
 519               	/* stack size = 6 */
 520               	.L__stack_usage = 6
 521 01f2 7C01      		movw r14,r24
 163:ServoController.c **** 	(*servoSwitchPtr)->number=(*start-48);
 522               		.loc 1 163 0
 523 01f4 E091 0000 		lds r30,servoSwitchPtr
 524 01f8 F091 0000 		lds r31,servoSwitchPtr+1
 525 01fc 0081      		ld r16,Z
 526 01fe 1181      		ldd r17,Z+1
 527 0200 EC01      		movw r28,r24
 528 0202 2991      		ld r18,Y+
 529 0204 30E0      		ldi r19,0
 530 0206 2053      		subi r18,48
 531 0208 3109      		sbc r19,__zero_reg__
 532 020a F801      		movw r30,r16
 533 020c 3383      		std Z+3,r19
 534 020e 2283      		std Z+2,r18
 164:ServoController.c **** 	(*servoSwitchPtr)->angle=StringToInt(start+1);
 535               		.loc 1 164 0
 536 0210 CE01      		movw r24,r28
 537               	.LVL45:
 538 0212 0E94 0000 		call StringToInt
 539               	.LVL46:
 540 0216 F801      		movw r30,r16
 541 0218 9183      		std Z+1,r25
 542 021a 8083      		st Z,r24
 165:ServoController.c **** 	(*servoSwitchPtrDup)->number=(*start-48);
 543               		.loc 1 165 0
 544 021c E091 0000 		lds r30,servoSwitchPtrDup
 545 0220 F091 0000 		lds r31,servoSwitchPtrDup+1
 546 0224 0081      		ld r16,Z
 547 0226 1181      		ldd r17,Z+1
 548 0228 F701      		movw r30,r14
 549 022a 8081      		ld r24,Z
 550 022c 90E0      		ldi r25,0
 551 022e C097      		sbiw r24,48
 552 0230 F801      		movw r30,r16
 553 0232 9383      		std Z+3,r25
 554 0234 8283      		std Z+2,r24
 166:ServoController.c **** 	(*servoSwitchPtrDup)->angle=StringToInt(start+1);
 555               		.loc 1 166 0
 556 0236 CE01      		movw r24,r28
 557 0238 0E94 0000 		call StringToInt
 558               	.LVL47:
 559 023c F801      		movw r30,r16
 560 023e 9183      		std Z+1,r25
 561 0240 8083      		st Z,r24
 562               	/* epilogue start */
 167:ServoController.c **** }
 563               		.loc 1 167 0
 564 0242 DF91      		pop r29
 565 0244 CF91      		pop r28
 566 0246 1F91      		pop r17
 567 0248 0F91      		pop r16
 568 024a FF90      		pop r15
 569 024c EF90      		pop r14
 570               	.LVL48:
 571 024e 0895      		ret
 572               		.cfi_endproc
 573               	.LFE9:
 575               	.global	SendList
 577               	SendList:
 578               	.LFB12:
 185:ServoController.c **** 
 186:ServoController.c **** servoList* SendList(servoList* head)
 187:ServoController.c **** {
 579               		.loc 1 187 0
 580               		.cfi_startproc
 581               	.LVL49:
 582 0250 0F93      		push r16
 583               	.LCFI24:
 584               		.cfi_def_cfa_offset 3
 585               		.cfi_offset 16, -2
 586 0252 1F93      		push r17
 587               	.LCFI25:
 588               		.cfi_def_cfa_offset 4
 589               		.cfi_offset 17, -3
 590 0254 CF93      		push r28
 591               	.LCFI26:
 592               		.cfi_def_cfa_offset 5
 593               		.cfi_offset 28, -4
 594 0256 DF93      		push r29
 595               	.LCFI27:
 596               		.cfi_def_cfa_offset 6
 597               		.cfi_offset 29, -5
 598               	/* prologue: function */
 599               	/* frame size = 0 */
 600               	/* stack size = 4 */
 601               	.L__stack_usage = 4
 602 0258 8C01      		movw r16,r24
 603               	.LVL50:
 188:ServoController.c **** 	servoList *tempServo=head;
 604               		.loc 1 188 0
 605 025a C82F      		mov r28,r24
 606 025c D12F      		mov r29,r17
 607               	.LVL51:
 608               	.L45:
 189:ServoController.c **** 	while(tempServo!=NULL){
 609               		.loc 1 189 0 discriminator 1
 610 025e 2097      		sbiw r28,0
 611 0260 01F0      		breq .L49
 612               	.L47:
 190:ServoController.c **** 		while(!(UCSRA && (1<<UDRE)));
 613               		.loc 1 190 0
 614 0262 8BB1      		in r24,0xb
 615 0264 8823      		tst r24
 616 0266 01F0      		breq .L47
 191:ServoController.c **** 		SendInteger(tempServo->angle);
 617               		.loc 1 191 0
 618 0268 8881      		ld r24,Y
 619 026a 9981      		ldd r25,Y+1
 620 026c 0E94 0000 		call SendInteger
 621               	.LVL52:
 192:ServoController.c **** 		SendInteger(tempServo->number);
 622               		.loc 1 192 0
 623 0270 8A81      		ldd r24,Y+2
 624 0272 9B81      		ldd r25,Y+3
 625 0274 0E94 0000 		call SendInteger
 626               	.LVL53:
 193:ServoController.c **** 		tempServo=tempServo->node ;
 627               		.loc 1 193 0
 628 0278 0C80      		ldd __tmp_reg__,Y+4
 629 027a DD81      		ldd r29,Y+5
 630 027c C02D      		mov r28,__tmp_reg__
 631               	.LVL54:
 632 027e 00C0      		rjmp .L45
 633               	.L49:
 194:ServoController.c **** 		}
 195:ServoController.c **** 	return head;
 196:ServoController.c **** }
 634               		.loc 1 196 0
 635 0280 C801      		movw r24,r16
 636               	/* epilogue start */
 637 0282 DF91      		pop r29
 638 0284 CF91      		pop r28
 639               	.LVL55:
 640 0286 1F91      		pop r17
 641 0288 0F91      		pop r16
 642               	.LVL56:
 643 028a 0895      		ret
 644               		.cfi_endproc
 645               	.LFE12:
 647               	.global	USARTInit
 649               	USARTInit:
 650               	.LFB14:
 197:ServoController.c **** 
 198:ServoController.c **** //ALWAYS KEEP A DELAY OF ABOUT 2MS OR 3MS (MINIMUM) BETWEEN THE TRANSMITTION OF 2 CONSECUTIVE DATA/
 199:ServoController.c **** int main(void)
 200:ServoController.c **** {
 201:ServoController.c **** 	tempDataPtr=tempData;
 202:ServoController.c **** 	servoList *servoNodeHead;
 203:ServoController.c **** 	servoList *servoNodeHeadDup;
 204:ServoController.c **** 	servoNodeHead=CreateList();
 205:ServoController.c **** 	servoNodeHeadDup=CreateList();
 206:ServoController.c **** 	servoSwitchListPtr=&servoNodeHead;
 207:ServoController.c **** 	//servoHead=tempServoHead=servoNodeHead;
 208:ServoController.c **** 	tempServoHead=*servoSwitchListPtr;
 209:ServoController.c **** 	servoSwitch=(servoList*)malloc(sizeof(servoList));
 210:ServoController.c **** 	servoSwitchDup=(servoList*)malloc(sizeof(servoList));
 211:ServoController.c **** 	servoSwitchPtr=&servoSwitch;
 212:ServoController.c **** 	servoSwitchPtrDup=&servoSwitchDup;
 213:ServoController.c **** 	
 214:ServoController.c **** 	clearbit(UCSRA,RXC);
 215:ServoController.c **** 	USARTInit();
 216:ServoController.c **** 	ServoPortInit();
 217:ServoController.c **** 	TimerInit();
 218:ServoController.c **** 	TCNT1=0;
 219:ServoController.c **** 	sei();
 220:ServoController.c **** 	while(1){
 221:ServoController.c **** 			//Without Delay the below loop is not executing.
 222:ServoController.c **** 			_delay_us(1); 
 223:ServoController.c **** 			if(arrangeSignalFlag==1){
 224:ServoController.c **** 				PrepareAddToList(tempData);
 225:ServoController.c **** 				/*
 226:ServoController.c **** 				SendList(servoNodeHeadDup);
 227:ServoController.c **** 				SendInteger((*servoSwitchPtrDup)->number);
 228:ServoController.c **** 				SendInteger((*servoSwitchPtrDup)->angle);
 229:ServoController.c **** 				servoNodeHeadDup=ArrangeAngle(servoSwitchDup,servoNodeHeadDup,0);
 230:ServoController.c **** 				SendList(servoNodeHeadDup);
 231:ServoController.c **** 				SendInteger((*servoSwitchPtrDup)->number);
 232:ServoController.c **** 				SendInteger((*servoSwitchPtrDup)->angle);
 233:ServoController.c **** 				//SendList(servoNodeHead);
 234:ServoController.c **** 				SendList(servoNodeHead);
 235:ServoController.c **** 				SendInteger((*servoSwitchPtr)->number);
 236:ServoController.c **** 				SendInteger((*servoSwitchPtr)->angle);
 237:ServoController.c **** 				servoNodeHead=ArrangeAngle(servoSwitch,servoNodeHead,1);
 238:ServoController.c **** 				SendList(servoNodeHead);
 239:ServoController.c **** 				SendInteger((*servoSwitchPtr)->number);
 240:ServoController.c **** 				SendInteger((*servoSwitchPtr)->angle);
 241:ServoController.c **** 				*/
 242:ServoController.c **** 				if(servoSwitchListPtr==&servoNodeHead){
 243:ServoController.c **** 					servoNodeHeadDup=ArrangeAngle(*servoSwitchPtrDup,servoNodeHeadDup,0);
 244:ServoController.c **** 					servoSwitchListPtr=&servoNodeHeadDup;
 245:ServoController.c **** 					servoNodeHead=ArrangeAngle(*servoSwitchPtr,servoNodeHead,1);
 246:ServoController.c **** 				}
 247:ServoController.c **** 				else{
 248:ServoController.c **** 					servoNodeHead=ArrangeAngle(*servoSwitchPtr,servoNodeHead,1);
 249:ServoController.c **** 					servoSwitchListPtr=&servoNodeHead;
 250:ServoController.c **** 					servoNodeHeadDup=ArrangeAngle(*servoSwitchPtrDup,servoNodeHeadDup,0);
 251:ServoController.c **** 				}
 252:ServoController.c **** 				tempDataPtr=tempData;
 253:ServoController.c **** 				arrangeSignalFlag=0;
 254:ServoController.c **** 				count=0;
 255:ServoController.c **** 			/*if(arrangeSignalFlag==1){
 256:ServoController.c **** 			PrepareAddToList(tempData);
 257:ServoController.c **** 			SendList(servoNodeHead);
 258:ServoController.c **** 			SendInteger((*servoSwitchPtr)->angle);
 259:ServoController.c **** 			SendInteger((*servoSwitchPtr)->number);
 260:ServoController.c **** 			servoNodeHead=ArrangeAngle(*servoSwitchPtr,servoNodeHead,1);
 261:ServoController.c **** 			SendInteger((*servoSwitchPtr)->angle);
 262:ServoController.c **** 			SendInteger((*servoSwitchPtr)->number);
 263:ServoController.c **** 			servoHead=servoNodeHead;	//
 264:ServoController.c **** 			SendList(servoNodeHead);
 265:ServoController.c **** 			tempDataPtr=tempData;
 266:ServoController.c **** 			arrangeSignalFlag=0;
 267:ServoController.c **** 			count=0;*/
 268:ServoController.c **** 			}
 269:ServoController.c **** 	}
 270:ServoController.c **** return 0;
 271:ServoController.c **** }
 272:ServoController.c **** 
 273:ServoController.c **** 
 274:ServoController.c **** void USARTInit()
 275:ServoController.c **** {
 651               		.loc 1 275 0
 652               		.cfi_startproc
 653               	/* prologue: function */
 654               	/* frame size = 0 */
 655               	/* stack size = 0 */
 656               	.L__stack_usage = 0
 276:ServoController.c **** 	UCSRB |=(1<<RXEN)|(1<<TXEN)|(1<<RXCIE);					//Enabling the Receiver and Receiver Interrupt
 657               		.loc 1 276 0
 658 028c 8AB1      		in r24,0xa
 659 028e 8869      		ori r24,lo8(-104)
 660 0290 8AB9      		out 0xa,r24
 277:ServoController.c **** 	UCSRC |=(1<<URSEL)|(1<<UCSZ1)|(1<<UCSZ0);
 661               		.loc 1 277 0
 662 0292 80B5      		in r24,0x20
 663 0294 8668      		ori r24,lo8(-122)
 664 0296 80BD      		out 0x20,r24
 278:ServoController.c **** 	UBRRL = baudRate;
 665               		.loc 1 278 0
 666 0298 8091 0000 		lds r24,baudRate
 667 029c 89B9      		out 0x9,r24
 279:ServoController.c **** 	UBRRH &=~(1<<URSEL);
 668               		.loc 1 279 0
 669 029e 80B5      		in r24,0x20
 670 02a0 8F77      		andi r24,lo8(127)
 671 02a2 80BD      		out 0x20,r24
 280:ServoController.c **** 	UBRRH = (baudRate<<8);
 672               		.loc 1 280 0
 673 02a4 10BC      		out 0x20,__zero_reg__
 674 02a6 0895      		ret
 675               		.cfi_endproc
 676               	.LFE14:
 678               	.global	TimerInit
 680               	TimerInit:
 681               	.LFB15:
 281:ServoController.c **** 	//clearbit(UCSRA,RXC);									//RXC bit needs to set to zero before enabling interrupt
 282:ServoController.c **** }
 283:ServoController.c **** 
 284:ServoController.c **** void TimerInit()
 285:ServoController.c **** {
 682               		.loc 1 285 0
 683               		.cfi_startproc
 684               	/* prologue: function */
 685               	/* frame size = 0 */
 686               	/* stack size = 0 */
 687               	.L__stack_usage = 0
 286:ServoController.c **** 	//TCCR1A |=((0<<WGM11)|(0<<WGM10));	 //NO CHANGES IN THE TCCR1A REGISTER
 287:ServoController.c **** 	TCCR1B |=(1<<WGM12)|(1<<WGM13)|(1<<CS11);//CTC MODE(12) - TOP VALUE - ICR1 AND PRESCALAR => 8
 688               		.loc 1 287 0
 689 02a8 8EB5      		in r24,0x2e
 690 02aa 8A61      		ori r24,lo8(26)
 691 02ac 8EBD      		out 0x2e,r24
 288:ServoController.c **** 	TIMSK |=(1<<TICIE1);			 //ENABLING INTERRUPT FOR TCNT1 REGISTER MATCHING ICR1
 692               		.loc 1 288 0
 693 02ae 89B7      		in r24,0x39
 694 02b0 8062      		ori r24,lo8(32)
 695 02b2 89BF      		out 0x39,r24
 696 02b4 0895      		ret
 697               		.cfi_endproc
 698               	.LFE15:
 700               	.global	ServoPortInit
 702               	ServoPortInit:
 703               	.LFB16:
 289:ServoController.c **** }
 290:ServoController.c **** 
 291:ServoController.c **** void ServoPortInit()
 292:ServoController.c **** {
 704               		.loc 1 292 0
 705               		.cfi_startproc
 706               	/* prologue: function */
 707               	/* frame size = 0 */
 708               	/* stack size = 0 */
 709               	.L__stack_usage = 0
 293:ServoController.c **** 	DDRB = 0xff;
 710               		.loc 1 293 0
 711 02b6 8FEF      		ldi r24,lo8(-1)
 712 02b8 87BB      		out 0x17,r24
 294:ServoController.c **** 	PORTB= 0xff;
 713               		.loc 1 294 0
 714 02ba 88BB      		out 0x18,r24
 715 02bc 0895      		ret
 716               		.cfi_endproc
 717               	.LFE16:
 719               		.section	.text.startup,"ax",@progbits
 720               	.global	main
 722               	main:
 723               	.LFB13:
 200:ServoController.c **** {
 724               		.loc 1 200 0
 725               		.cfi_startproc
 726 0000 CF93      		push r28
 727               	.LCFI28:
 728               		.cfi_def_cfa_offset 3
 729               		.cfi_offset 28, -2
 730 0002 DF93      		push r29
 731               	.LCFI29:
 732               		.cfi_def_cfa_offset 4
 733               		.cfi_offset 29, -3
 734 0004 00D0      		rcall .
 735 0006 00D0      		rcall .
 736               	.LCFI30:
 737               		.cfi_def_cfa_offset 8
 738 0008 CDB7      		in r28,__SP_L__
 739 000a DEB7      		in r29,__SP_H__
 740               	.LCFI31:
 741               		.cfi_def_cfa_register 28
 742               	/* prologue: function */
 743               	/* frame size = 4 */
 744               	/* stack size = 6 */
 745               	.L__stack_usage = 6
 201:ServoController.c **** 	tempDataPtr=tempData;
 746               		.loc 1 201 0
 747 000c 80E0      		ldi r24,lo8(tempData)
 748 000e 90E0      		ldi r25,hi8(tempData)
 749 0010 9093 0000 		sts tempDataPtr+1,r25
 750 0014 8093 0000 		sts tempDataPtr,r24
 204:ServoController.c **** 	servoNodeHead=CreateList();
 751               		.loc 1 204 0
 752 0018 0E94 0000 		call CreateList
 753               	.LVL57:
 754 001c 9C83      		std Y+4,r25
 755 001e 8B83      		std Y+3,r24
 205:ServoController.c **** 	servoNodeHeadDup=CreateList();
 756               		.loc 1 205 0
 757 0020 0E94 0000 		call CreateList
 758               	.LVL58:
 759 0024 9A83      		std Y+2,r25
 760 0026 8983      		std Y+1,r24
 206:ServoController.c **** 	servoSwitchListPtr=&servoNodeHead;
 761               		.loc 1 206 0
 762 0028 CE01      		movw r24,r28
 763 002a 0396      		adiw r24,3
 764 002c 9093 0000 		sts servoSwitchListPtr+1,r25
 765 0030 8093 0000 		sts servoSwitchListPtr,r24
 208:ServoController.c **** 	tempServoHead=*servoSwitchListPtr;
 766               		.loc 1 208 0
 767 0034 8B81      		ldd r24,Y+3
 768 0036 9C81      		ldd r25,Y+4
 769 0038 9093 0000 		sts tempServoHead+1,r25
 770 003c 8093 0000 		sts tempServoHead,r24
 209:ServoController.c **** 	servoSwitch=(servoList*)malloc(sizeof(servoList));
 771               		.loc 1 209 0
 772 0040 86E0      		ldi r24,lo8(6)
 773 0042 90E0      		ldi r25,0
 774 0044 0E94 0000 		call malloc
 775               	.LVL59:
 776 0048 9093 0000 		sts servoSwitch+1,r25
 777 004c 8093 0000 		sts servoSwitch,r24
 210:ServoController.c **** 	servoSwitchDup=(servoList*)malloc(sizeof(servoList));
 778               		.loc 1 210 0
 779 0050 86E0      		ldi r24,lo8(6)
 780 0052 90E0      		ldi r25,0
 781 0054 0E94 0000 		call malloc
 782               	.LVL60:
 783 0058 9093 0000 		sts servoSwitchDup+1,r25
 784 005c 8093 0000 		sts servoSwitchDup,r24
 211:ServoController.c **** 	servoSwitchPtr=&servoSwitch;
 785               		.loc 1 211 0
 786 0060 80E0      		ldi r24,lo8(servoSwitch)
 787 0062 90E0      		ldi r25,hi8(servoSwitch)
 788 0064 9093 0000 		sts servoSwitchPtr+1,r25
 789 0068 8093 0000 		sts servoSwitchPtr,r24
 212:ServoController.c **** 	servoSwitchPtrDup=&servoSwitchDup;
 790               		.loc 1 212 0
 791 006c 80E0      		ldi r24,lo8(servoSwitchDup)
 792 006e 90E0      		ldi r25,hi8(servoSwitchDup)
 793 0070 9093 0000 		sts servoSwitchPtrDup+1,r25
 794 0074 8093 0000 		sts servoSwitchPtrDup,r24
 214:ServoController.c **** 	clearbit(UCSRA,RXC);
 795               		.loc 1 214 0
 796 0078 5F98      		cbi 0xb,7
 215:ServoController.c **** 	USARTInit();
 797               		.loc 1 215 0
 798 007a 0E94 0000 		call USARTInit
 799               	.LVL61:
 216:ServoController.c **** 	ServoPortInit();
 800               		.loc 1 216 0
 801 007e 0E94 0000 		call ServoPortInit
 802               	.LVL62:
 217:ServoController.c **** 	TimerInit();
 803               		.loc 1 217 0
 804 0082 0E94 0000 		call TimerInit
 805               	.LVL63:
 218:ServoController.c **** 	TCNT1=0;
 806               		.loc 1 218 0
 807 0086 1DBC      		out 0x2c+1,__zero_reg__
 808 0088 1CBC      		out 0x2c,__zero_reg__
 219:ServoController.c **** 	sei();
 809               		.loc 1 219 0
 810               	/* #APP */
 811               	 ;  219 "ServoController.c" 1
 812 008a 7894      		sei
 813               	 ;  0 "" 2
 814               	/* #NOAPP */
 815 008c 8E01      		movw r16,r28
 816 008e 0D5F      		subi r16,-3
 817 0090 1F4F      		sbci r17,-1
 244:ServoController.c **** 					servoSwitchListPtr=&servoNodeHeadDup;
 818               		.loc 1 244 0
 819 0092 CE01      		movw r24,r28
 820 0094 0196      		adiw r24,1
 821 0096 7C01      		movw r14,r24
 822               	.L55:
 823               	.LVL64:
 824               	.LBB9:
 825               	.LBB10:
 165:/usr/lib/avr/include/util/delay.h **** 
 166:/usr/lib/avr/include/util/delay.h **** #else
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/lib/avr/include/util/delay.h **** 
 235:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/lib/avr/include/util/delay.h **** 
 238:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h **** 	#else
 242:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 243:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/lib/avr/include/util/delay.h **** 	#endif
 245:/usr/lib/avr/include/util/delay.h **** 
 246:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 826               		.loc 2 246 0
 827 0098 95E0      		ldi r25,lo8(5)
 828 009a 9A95      		1: dec r25
 829 009c 01F4      		brne 1b
 830 009e 0000      		nop
 831               	.LBE10:
 832               	.LBE9:
 223:ServoController.c **** 			if(arrangeSignalFlag==1){
 833               		.loc 1 223 0
 834 00a0 8091 0000 		lds r24,arrangeSignalFlag
 835 00a4 9091 0000 		lds r25,arrangeSignalFlag+1
 836 00a8 0197      		sbiw r24,1
 837 00aa 01F4      		brne .L55
 224:ServoController.c **** 				PrepareAddToList(tempData);
 838               		.loc 1 224 0
 839 00ac 80E0      		ldi r24,lo8(tempData)
 840 00ae 90E0      		ldi r25,hi8(tempData)
 841 00b0 0E94 0000 		call PrepareAddToList
 842               	.LVL65:
 242:ServoController.c **** 				if(servoSwitchListPtr==&servoNodeHead){
 843               		.loc 1 242 0
 844 00b4 8091 0000 		lds r24,servoSwitchListPtr
 845 00b8 9091 0000 		lds r25,servoSwitchListPtr+1
 846 00bc 8017      		cp r24,r16
 847 00be 9107      		cpc r25,r17
 848 00c0 01F4      		brne .L56
 243:ServoController.c **** 					servoNodeHeadDup=ArrangeAngle(*servoSwitchPtrDup,servoNodeHeadDup,0);
 849               		.loc 1 243 0
 850 00c2 6981      		ldd r22,Y+1
 851 00c4 7A81      		ldd r23,Y+2
 852 00c6 E091 0000 		lds r30,servoSwitchPtrDup
 853 00ca F091 0000 		lds r31,servoSwitchPtrDup+1
 854 00ce 40E0      		ldi r20,0
 855 00d0 50E0      		ldi r21,0
 856 00d2 8081      		ld r24,Z
 857 00d4 9181      		ldd r25,Z+1
 858 00d6 0E94 0000 		call ArrangeAngle
 859               	.LVL66:
 860 00da 9A83      		std Y+2,r25
 861 00dc 8983      		std Y+1,r24
 244:ServoController.c **** 					servoSwitchListPtr=&servoNodeHeadDup;
 862               		.loc 1 244 0
 863 00de F092 0000 		sts servoSwitchListPtr+1,r15
 864 00e2 E092 0000 		sts servoSwitchListPtr,r14
 245:ServoController.c **** 					servoNodeHead=ArrangeAngle(*servoSwitchPtr,servoNodeHead,1);
 865               		.loc 1 245 0
 866 00e6 6B81      		ldd r22,Y+3
 867 00e8 7C81      		ldd r23,Y+4
 868 00ea E091 0000 		lds r30,servoSwitchPtr
 869 00ee F091 0000 		lds r31,servoSwitchPtr+1
 870 00f2 41E0      		ldi r20,lo8(1)
 871 00f4 50E0      		ldi r21,0
 872 00f6 8081      		ld r24,Z
 873 00f8 9181      		ldd r25,Z+1
 874 00fa 0E94 0000 		call ArrangeAngle
 875               	.LVL67:
 876 00fe 9C83      		std Y+4,r25
 877 0100 8B83      		std Y+3,r24
 878 0102 00C0      		rjmp .L57
 879               	.L56:
 248:ServoController.c **** 					servoNodeHead=ArrangeAngle(*servoSwitchPtr,servoNodeHead,1);
 880               		.loc 1 248 0
 881 0104 6B81      		ldd r22,Y+3
 882 0106 7C81      		ldd r23,Y+4
 883 0108 E091 0000 		lds r30,servoSwitchPtr
 884 010c F091 0000 		lds r31,servoSwitchPtr+1
 885 0110 41E0      		ldi r20,lo8(1)
 886 0112 50E0      		ldi r21,0
 887 0114 8081      		ld r24,Z
 888 0116 9181      		ldd r25,Z+1
 889 0118 0E94 0000 		call ArrangeAngle
 890               	.LVL68:
 891 011c 9C83      		std Y+4,r25
 892 011e 8B83      		std Y+3,r24
 249:ServoController.c **** 					servoSwitchListPtr=&servoNodeHead;
 893               		.loc 1 249 0
 894 0120 1093 0000 		sts servoSwitchListPtr+1,r17
 895 0124 0093 0000 		sts servoSwitchListPtr,r16
 250:ServoController.c **** 					servoNodeHeadDup=ArrangeAngle(*servoSwitchPtrDup,servoNodeHeadDup,0);
 896               		.loc 1 250 0
 897 0128 6981      		ldd r22,Y+1
 898 012a 7A81      		ldd r23,Y+2
 899 012c E091 0000 		lds r30,servoSwitchPtrDup
 900 0130 F091 0000 		lds r31,servoSwitchPtrDup+1
 901 0134 40E0      		ldi r20,0
 902 0136 50E0      		ldi r21,0
 903 0138 8081      		ld r24,Z
 904 013a 9181      		ldd r25,Z+1
 905 013c 0E94 0000 		call ArrangeAngle
 906               	.LVL69:
 907 0140 9A83      		std Y+2,r25
 908 0142 8983      		std Y+1,r24
 909               	.L57:
 252:ServoController.c **** 				tempDataPtr=tempData;
 910               		.loc 1 252 0
 911 0144 80E0      		ldi r24,lo8(tempData)
 912 0146 90E0      		ldi r25,hi8(tempData)
 913 0148 9093 0000 		sts tempDataPtr+1,r25
 914 014c 8093 0000 		sts tempDataPtr,r24
 253:ServoController.c **** 				arrangeSignalFlag=0;
 915               		.loc 1 253 0
 916 0150 1092 0000 		sts arrangeSignalFlag+1,__zero_reg__
 917 0154 1092 0000 		sts arrangeSignalFlag,__zero_reg__
 254:ServoController.c **** 				count=0;
 918               		.loc 1 254 0
 919 0158 1092 0000 		sts count+1,__zero_reg__
 920 015c 1092 0000 		sts count,__zero_reg__
 921 0160 00C0      		rjmp .L55
 922               		.cfi_endproc
 923               	.LFE13:
 925               	.global	__floatunsisf
 926               	.global	__mulsf3
 927               	.global	__addsf3
 928               	.global	__fixunssfsi
 929               	.global	__subsf3
 930               		.text
 931               	.global	__vector_6
 933               	__vector_6:
 934               	.LFB17:
 295:ServoController.c **** }
 296:ServoController.c **** 
 297:ServoController.c **** //*************************************************************************************************
 298:ServoController.c **** //	      									INTERRUPTS  								       	       //
 299:ServoController.c **** //*************************************************************************************************
 300:ServoController.c **** ISR(TIMER1_CAPT_vect)
 301:ServoController.c **** {
 935               		.loc 1 301 0
 936               		.cfi_startproc
 937 02be 1F92      		push r1
 938               	.LCFI32:
 939               		.cfi_def_cfa_offset 3
 940               		.cfi_offset 1, -2
 941 02c0 0F92      		push r0
 942               	.LCFI33:
 943               		.cfi_def_cfa_offset 4
 944               		.cfi_offset 0, -3
 945 02c2 0FB6      		in r0,__SREG__
 946 02c4 0F92      		push r0
 947 02c6 1124      		clr __zero_reg__
 948 02c8 2F93      		push r18
 949               	.LCFI34:
 950               		.cfi_def_cfa_offset 5
 951               		.cfi_offset 18, -4
 952 02ca 3F93      		push r19
 953               	.LCFI35:
 954               		.cfi_def_cfa_offset 6
 955               		.cfi_offset 19, -5
 956 02cc 4F93      		push r20
 957               	.LCFI36:
 958               		.cfi_def_cfa_offset 7
 959               		.cfi_offset 20, -6
 960 02ce 5F93      		push r21
 961               	.LCFI37:
 962               		.cfi_def_cfa_offset 8
 963               		.cfi_offset 21, -7
 964 02d0 6F93      		push r22
 965               	.LCFI38:
 966               		.cfi_def_cfa_offset 9
 967               		.cfi_offset 22, -8
 968 02d2 7F93      		push r23
 969               	.LCFI39:
 970               		.cfi_def_cfa_offset 10
 971               		.cfi_offset 23, -9
 972 02d4 8F93      		push r24
 973               	.LCFI40:
 974               		.cfi_def_cfa_offset 11
 975               		.cfi_offset 24, -10
 976 02d6 9F93      		push r25
 977               	.LCFI41:
 978               		.cfi_def_cfa_offset 12
 979               		.cfi_offset 25, -11
 980 02d8 AF93      		push r26
 981               	.LCFI42:
 982               		.cfi_def_cfa_offset 13
 983               		.cfi_offset 26, -12
 984 02da BF93      		push r27
 985               	.LCFI43:
 986               		.cfi_def_cfa_offset 14
 987               		.cfi_offset 27, -13
 988 02dc CF93      		push r28
 989               	.LCFI44:
 990               		.cfi_def_cfa_offset 15
 991               		.cfi_offset 28, -14
 992 02de DF93      		push r29
 993               	.LCFI45:
 994               		.cfi_def_cfa_offset 16
 995               		.cfi_offset 29, -15
 996 02e0 EF93      		push r30
 997               	.LCFI46:
 998               		.cfi_def_cfa_offset 17
 999               		.cfi_offset 30, -16
 1000 02e2 FF93      		push r31
 1001               	.LCFI47:
 1002               		.cfi_def_cfa_offset 18
 1003               		.cfi_offset 31, -17
 1004               	/* prologue: Signal */
 1005               	/* frame size = 0 */
 1006               	/* stack size = 17 */
 1007               	.L__stack_usage = 17
 302:ServoController.c **** 	if(count==0){
 1008               		.loc 1 302 0
 1009 02e4 8091 0000 		lds r24,count
 1010 02e8 9091 0000 		lds r25,count+1
 1011 02ec 892B      		or r24,r25
 1012 02ee 01F4      		brne .L60
 303:ServoController.c **** 		//tempServoHead=servoHead;
 304:ServoController.c **** 		PORTB=0xff;
 1013               		.loc 1 304 0
 1014 02f0 8FEF      		ldi r24,lo8(-1)
 1015 02f2 88BB      		out 0x18,r24
 305:ServoController.c **** 		ICR1=ICR1_BASE_VALUE+(tempServoHead->angle)*FACTOR;			//struct 0 angle
 1016               		.loc 1 305 0
 1017 02f4 E091 0000 		lds r30,tempServoHead
 1018 02f8 F091 0000 		lds r31,tempServoHead+1
 1019 02fc 6081      		ld r22,Z
 1020 02fe 7181      		ldd r23,Z+1
 1021 0300 80E0      		ldi r24,0
 1022 0302 90E0      		ldi r25,0
 1023 0304 0E94 0000 		call __floatunsisf
 1024               	.LVL70:
 1025 0308 2FE8      		ldi r18,lo8(-113)
 1026 030a 32EC      		ldi r19,lo8(-62)
 1027 030c 41EB      		ldi r20,lo8(-79)
 1028 030e 51E4      		ldi r21,lo8(65)
 1029 0310 0E94 0000 		call __mulsf3
 1030               	.LVL71:
 1031 0314 20E0      		ldi r18,0
 1032 0316 30E8      		ldi r19,lo8(-128)
 1033 0318 49E8      		ldi r20,lo8(-119)
 1034 031a 54E4      		ldi r21,lo8(68)
 1035 031c 0E94 0000 		call __addsf3
 1036               	.LVL72:
 1037 0320 0E94 0000 		call __fixunssfsi
 1038               	.LVL73:
 1039 0324 77BD      		out 0x26+1,r23
 1040 0326 66BD      		out 0x26,r22
 1041               	.L60:
 306:ServoController.c **** 	}
 307:ServoController.c **** 	while(((tempServoHead->number==tempServoHead->node->number)&&count<=7)&&count>=1){
 308:ServoController.c **** 		clearbit(PORTB,((tempServoHead->number)-1));
 1042               		.loc 1 308 0 discriminator 1
 1043 0328 61E0      		ldi r22,lo8(1)
 1044 032a 70E0      		ldi r23,0
 1045               	.L61:
 307:ServoController.c **** 	while(((tempServoHead->number==tempServoHead->node->number)&&count<=7)&&count>=1){
 1046               		.loc 1 307 0 discriminator 1
 1047 032c E091 0000 		lds r30,tempServoHead
 1048 0330 F091 0000 		lds r31,tempServoHead+1
 1049 0334 8281      		ldd r24,Z+2
 1050 0336 9381      		ldd r25,Z+3
 1051 0338 0480      		ldd __tmp_reg__,Z+4
 1052 033a F581      		ldd r31,Z+5
 1053 033c E02D      		mov r30,__tmp_reg__
 1054 033e 4281      		ldd r20,Z+2
 1055 0340 5381      		ldd r21,Z+3
 1056 0342 2091 0000 		lds r18,count
 1057 0346 3091 0000 		lds r19,count+1
 1058 034a 8417      		cp r24,r20
 1059 034c 9507      		cpc r25,r21
 1060 034e 01F0      		breq .L62
 1061               	.L66:
 309:ServoController.c **** 		tempServoHead=tempServoHead->node;
 310:ServoController.c **** 		count++;
 311:ServoController.c **** 	}
 312:ServoController.c **** 	if((1<=count)&&(count<=7)){
 1062               		.loc 1 312 0
 1063 0350 2150      		subi r18,1
 1064 0352 3109      		sbc r19,__zero_reg__
 1065 0354 2730      		cpi r18,7
 1066 0356 3105      		cpc r19,__zero_reg__
 1067 0358 00F0      		brlo .+2
 1068 035a 00C0      		rjmp .L64
 313:ServoController.c **** 		clearbit(PORTB,	((tempServoHead->number)-1));									//angle [i-1]
 1069               		.loc 1 313 0
 1070 035c 48B3      		in r20,0x18
 1071 035e 9C01      		movw r18,r24
 1072 0360 2150      		subi r18,1
 1073 0362 3109      		sbc r19,__zero_reg__
 1074 0364 81E0      		ldi r24,lo8(1)
 1075 0366 90E0      		ldi r25,0
 1076 0368 00C0      		rjmp 2f
 1077               		1:
 1078 036a 880F      		lsl r24
 1079               		2:
 1080 036c 2A95      		dec r18
 1081 036e 02F4      		brpl 1b
 1082 0370 8095      		com r24
 1083 0372 8423      		and r24,r20
 1084 0374 88BB      		out 0x18,r24
 314:ServoController.c **** 		ICR1=(tempServoHead->node->angle-tempServoHead->angle)*FACTOR;
 1085               		.loc 1 314 0
 1086 0376 E091 0000 		lds r30,tempServoHead
 1087 037a F091 0000 		lds r31,tempServoHead+1
 1088 037e C481      		ldd r28,Z+4
 1089 0380 D581      		ldd r29,Z+5
 1090 0382 6881      		ld r22,Y
 1091 0384 7981      		ldd r23,Y+1
 1092 0386 8081      		ld r24,Z
 1093 0388 9181      		ldd r25,Z+1
 1094 038a 681B      		sub r22,r24
 1095 038c 790B      		sbc r23,r25
 1096 038e 80E0      		ldi r24,0
 1097 0390 90E0      		ldi r25,0
 1098 0392 0E94 0000 		call __floatunsisf
 1099               	.LVL74:
 1100 0396 2FE8      		ldi r18,lo8(-113)
 1101 0398 32EC      		ldi r19,lo8(-62)
 1102 039a 41EB      		ldi r20,lo8(-79)
 1103 039c 51E4      		ldi r21,lo8(65)
 1104 039e 0E94 0000 		call __mulsf3
 1105               	.LVL75:
 1106 03a2 0E94 0000 		call __fixunssfsi
 1107               	.LVL76:
 1108 03a6 77BD      		out 0x26+1,r23
 1109 03a8 66BD      		out 0x26,r22
 315:ServoController.c **** 		tempServoHead=tempServoHead->node;
 1110               		.loc 1 315 0
 1111 03aa D093 0000 		sts tempServoHead+1,r29
 1112 03ae C093 0000 		sts tempServoHead,r28
 1113 03b2 00C0      		rjmp .L64
 1114               	.L62:
 307:ServoController.c **** 	while(((tempServoHead->number==tempServoHead->node->number)&&count<=7)&&count>=1){
 1115               		.loc 1 307 0 discriminator 2
 1116 03b4 A901      		movw r20,r18
 1117 03b6 4150      		subi r20,1
 1118 03b8 5109      		sbc r21,__zero_reg__
 1119 03ba 4730      		cpi r20,7
 1120 03bc 5105      		cpc r21,__zero_reg__
 1121 03be 00F4      		brsh .L66
 308:ServoController.c **** 		clearbit(PORTB,((tempServoHead->number)-1));
 1122               		.loc 1 308 0
 1123 03c0 28B3      		in r18,0x18
 1124 03c2 0197      		sbiw r24,1
 1125 03c4 AB01      		movw r20,r22
 1126 03c6 00C0      		rjmp 2f
 1127               		1:
 1128 03c8 440F      		lsl r20
 1129 03ca 551F      		rol r21
 1130               		2:
 1131 03cc 8A95      		dec r24
 1132 03ce 02F4      		brpl 1b
 1133 03d0 CA01      		movw r24,r20
 1134 03d2 8095      		com r24
 1135 03d4 8223      		and r24,r18
 1136 03d6 88BB      		out 0x18,r24
 309:ServoController.c **** 		tempServoHead=tempServoHead->node;
 1137               		.loc 1 309 0
 1138 03d8 E091 0000 		lds r30,tempServoHead
 1139 03dc F091 0000 		lds r31,tempServoHead+1
 1140 03e0 8481      		ldd r24,Z+4
 1141 03e2 9581      		ldd r25,Z+5
 1142 03e4 9093 0000 		sts tempServoHead+1,r25
 1143 03e8 8093 0000 		sts tempServoHead,r24
 310:ServoController.c **** 		count++;
 1144               		.loc 1 310 0
 1145 03ec 8091 0000 		lds r24,count
 1146 03f0 9091 0000 		lds r25,count+1
 1147 03f4 0196      		adiw r24,1
 1148 03f6 9093 0000 		sts count+1,r25
 1149 03fa 8093 0000 		sts count,r24
 1150 03fe 00C0      		rjmp .L61
 1151               	.L64:
 316:ServoController.c **** 		//Introduce a case for Zero Condition Angle example 2 or more than 2 consecutive angle can have s
 317:ServoController.c **** 	}
 318:ServoController.c **** 	if(count>7){
 1152               		.loc 1 318 0
 1153 0400 8091 0000 		lds r24,count
 1154 0404 9091 0000 		lds r25,count+1
 1155 0408 0897      		sbiw r24,8
 1156 040a 04F0      		brlt .L67
 319:ServoController.c **** 		clearbit(PORTB,((tempServoHead->number)-1));
 1157               		.loc 1 319 0
 1158 040c 48B3      		in r20,0x18
 1159 040e E091 0000 		lds r30,tempServoHead
 1160 0412 F091 0000 		lds r31,tempServoHead+1
 1161 0416 2281      		ldd r18,Z+2
 1162 0418 3381      		ldd r19,Z+3
 1163 041a 2150      		subi r18,1
 1164 041c 3109      		sbc r19,__zero_reg__
 1165 041e 81E0      		ldi r24,lo8(1)
 1166 0420 90E0      		ldi r25,0
 1167 0422 00C0      		rjmp 2f
 1168               		1:
 1169 0424 880F      		lsl r24
 1170               		2:
 1171 0426 2A95      		dec r18
 1172 0428 02F4      		brpl 1b
 1173 042a 8095      		com r24
 1174 042c 8423      		and r24,r20
 1175 042e 88BB      		out 0x18,r24
 320:ServoController.c **** 		ICR1=ICR1_TOP_VALUE-ICR1_BASE_VALUE-(tempServoHead->angle)*FACTOR;
 1176               		.loc 1 320 0
 1177 0430 E091 0000 		lds r30,tempServoHead
 1178 0434 F091 0000 		lds r31,tempServoHead+1
 1179 0438 6081      		ld r22,Z
 1180 043a 7181      		ldd r23,Z+1
 1181 043c 80E0      		ldi r24,0
 1182 043e 90E0      		ldi r25,0
 1183 0440 0E94 0000 		call __floatunsisf
 1184               	.LVL77:
 1185 0444 2FE8      		ldi r18,lo8(-113)
 1186 0446 32EC      		ldi r19,lo8(-62)
 1187 0448 41EB      		ldi r20,lo8(-79)
 1188 044a 51E4      		ldi r21,lo8(65)
 1189 044c 0E94 0000 		call __mulsf3
 1190               	.LVL78:
 1191 0450 9B01      		movw r18,r22
 1192 0452 AC01      		movw r20,r24
 1193 0454 60E0      		ldi r22,0
 1194 0456 70E3      		ldi r23,lo8(48)
 1195 0458 85E3      		ldi r24,lo8(53)
 1196 045a 95E4      		ldi r25,lo8(69)
 1197 045c 0E94 0000 		call __subsf3
 1198               	.LVL79:
 1199 0460 0E94 0000 		call __fixunssfsi
 1200               	.LVL80:
 1201 0464 77BD      		out 0x26+1,r23
 1202 0466 66BD      		out 0x26,r22
 321:ServoController.c **** 		tempServoHead=*servoSwitchListPtr;
 1203               		.loc 1 321 0
 1204 0468 E091 0000 		lds r30,servoSwitchListPtr
 1205 046c F091 0000 		lds r31,servoSwitchListPtr+1
 1206 0470 8081      		ld r24,Z
 1207 0472 9181      		ldd r25,Z+1
 1208 0474 9093 0000 		sts tempServoHead+1,r25
 1209 0478 8093 0000 		sts tempServoHead,r24
 322:ServoController.c **** 		//tempServoHead=servoHead;
 323:ServoController.c **** 		count=-1;
 1210               		.loc 1 323 0
 1211 047c 8FEF      		ldi r24,lo8(-1)
 1212 047e 9FEF      		ldi r25,lo8(-1)
 1213 0480 9093 0000 		sts count+1,r25
 1214 0484 8093 0000 		sts count,r24
 1215               	.L67:
 324:ServoController.c **** 	}
 325:ServoController.c **** 	count++;
 1216               		.loc 1 325 0
 1217 0488 8091 0000 		lds r24,count
 1218 048c 9091 0000 		lds r25,count+1
 1219 0490 0196      		adiw r24,1
 1220 0492 9093 0000 		sts count+1,r25
 1221 0496 8093 0000 		sts count,r24
 326:ServoController.c **** 	TCNT1=0;
 1222               		.loc 1 326 0
 1223 049a 1DBC      		out 0x2c+1,__zero_reg__
 1224 049c 1CBC      		out 0x2c,__zero_reg__
 1225               	/* epilogue start */
 327:ServoController.c **** }
 1226               		.loc 1 327 0
 1227 049e FF91      		pop r31
 1228 04a0 EF91      		pop r30
 1229 04a2 DF91      		pop r29
 1230 04a4 CF91      		pop r28
 1231 04a6 BF91      		pop r27
 1232 04a8 AF91      		pop r26
 1233 04aa 9F91      		pop r25
 1234 04ac 8F91      		pop r24
 1235 04ae 7F91      		pop r23
 1236 04b0 6F91      		pop r22
 1237 04b2 5F91      		pop r21
 1238 04b4 4F91      		pop r20
 1239 04b6 3F91      		pop r19
 1240 04b8 2F91      		pop r18
 1241 04ba 0F90      		pop r0
 1242 04bc 0FBE      		out __SREG__,r0
 1243 04be 0F90      		pop r0
 1244 04c0 1F90      		pop r1
 1245 04c2 1895      		reti
 1246               		.cfi_endproc
 1247               	.LFE17:
 1249               	.global	__vector_13
 1251               	__vector_13:
 1252               	.LFB18:
 328:ServoController.c **** 
 329:ServoController.c **** ISR(USART_RXC_vect)
 330:ServoController.c **** {
 1253               		.loc 1 330 0
 1254               		.cfi_startproc
 1255 04c4 1F92      		push r1
 1256               	.LCFI48:
 1257               		.cfi_def_cfa_offset 3
 1258               		.cfi_offset 1, -2
 1259 04c6 0F92      		push r0
 1260               	.LCFI49:
 1261               		.cfi_def_cfa_offset 4
 1262               		.cfi_offset 0, -3
 1263 04c8 0FB6      		in r0,__SREG__
 1264 04ca 0F92      		push r0
 1265 04cc 1124      		clr __zero_reg__
 1266 04ce 8F93      		push r24
 1267               	.LCFI50:
 1268               		.cfi_def_cfa_offset 5
 1269               		.cfi_offset 24, -4
 1270 04d0 9F93      		push r25
 1271               	.LCFI51:
 1272               		.cfi_def_cfa_offset 6
 1273               		.cfi_offset 25, -5
 1274 04d2 EF93      		push r30
 1275               	.LCFI52:
 1276               		.cfi_def_cfa_offset 7
 1277               		.cfi_offset 30, -6
 1278 04d4 FF93      		push r31
 1279               	.LCFI53:
 1280               		.cfi_def_cfa_offset 8
 1281               		.cfi_offset 31, -7
 1282               	/* prologue: Signal */
 1283               	/* frame size = 0 */
 1284               	/* stack size = 7 */
 1285               	.L__stack_usage = 7
 1286               	.L70:
 331:ServoController.c **** 	while(!(UCSRA &(1<<RXC)));	//For SAFETY Measure
 1287               		.loc 1 331 0 discriminator 1
 1288 04d6 5F9B      		sbis 0xb,7
 1289 04d8 00C0      		rjmp .L70
 332:ServoController.c **** 	*tempDataPtr=UDR;
 1290               		.loc 1 332 0
 1291 04da E091 0000 		lds r30,tempDataPtr
 1292 04de F091 0000 		lds r31,tempDataPtr+1
 1293 04e2 8CB1      		in r24,0xc
 1294 04e4 8083      		st Z,r24
 333:ServoController.c **** 	tempDataPtr++;
 1295               		.loc 1 333 0
 1296 04e6 E091 0000 		lds r30,tempDataPtr
 1297 04ea F091 0000 		lds r31,tempDataPtr+1
 1298 04ee CF01      		movw r24,r30
 1299 04f0 0196      		adiw r24,1
 1300 04f2 9093 0000 		sts tempDataPtr+1,r25
 1301 04f6 8093 0000 		sts tempDataPtr,r24
 334:ServoController.c **** 	if(*(tempDataPtr-1)==END_OF_SIGNAL){	//STOP CONDITION
 1302               		.loc 1 334 0
 1303 04fa 8081      		ld r24,Z
 1304 04fc 8D30      		cpi r24,lo8(13)
 1305 04fe 01F4      		brne .L68
 335:ServoController.c **** 		arrangeSignalFlag=1;	//Flag will activate the processing of received data//Arranging
 1306               		.loc 1 335 0
 1307 0500 81E0      		ldi r24,lo8(1)
 1308 0502 90E0      		ldi r25,0
 1309 0504 9093 0000 		sts arrangeSignalFlag+1,r25
 1310 0508 8093 0000 		sts arrangeSignalFlag,r24
 1311               	.L68:
 1312               	/* epilogue start */
 336:ServoController.c **** 	}
 337:ServoController.c **** }
 1313               		.loc 1 337 0
 1314 050c FF91      		pop r31
 1315 050e EF91      		pop r30
 1316 0510 9F91      		pop r25
 1317 0512 8F91      		pop r24
 1318 0514 0F90      		pop r0
 1319 0516 0FBE      		out __SREG__,r0
 1320 0518 0F90      		pop r0
 1321 051a 1F90      		pop r1
 1322 051c 1895      		reti
 1323               		.cfi_endproc
 1324               	.LFE18:
 1326               	.global	arrangeSignalFlag
 1327               		.section .bss
 1330               	arrangeSignalFlag:
 1331 0000 0000      		.zero	2
 1332               	.global	baudRate
 1333               		.data
 1336               	baudRate:
 1337 0000 6700      		.word	103
 1338               		.comm	tempDataPtr,2,1
 1339               	.global	tempData
 1340               		.section .bss
 1343               	tempData:
 1344 0002 0000 0000 		.zero	6
 1344      0000 
 1345               	.global	count
 1348               	count:
 1349 0008 0000      		.zero	2
 1350               	.global	flag1
 1351               		.data
 1354               	flag1:
 1355 0002 0100      		.word	1
 1356               	.global	servoStartAngle
 1359               	servoStartAngle:
 1360 0004 1900      		.word	25
 1361 0006 3200      		.word	50
 1362 0008 4B00      		.word	75
 1363 000a 6400      		.word	100
 1364 000c 7D00      		.word	125
 1365 000e 9600      		.word	150
 1366 0010 A000      		.word	160
 1367 0012 B300      		.word	179
 1368               		.comm	servoSwitchListPtr,2,1
 1369               		.comm	servoSwitchPtr,2,1
 1370               		.comm	servoSwitchPtrDup,2,1
 1371               		.comm	servoSwitchDup,2,1
 1372               		.comm	servoSwitch,2,1
 1373               		.comm	tempServoHead,2,1
 1374               		.comm	servoHead,2,1
 1375               		.text
 1376               	.Letext0:
 1377               		.file 3 "/usr/lib/avr/include/stdint.h"
 1378               		.file 4 "/usr/lib/gcc/avr/4.8.2/include/stddef.h"
 1379               		.file 5 "/usr/lib/avr/include/stdlib.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 ServoController.c
     /tmp/ccjxLSPH.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccjxLSPH.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccjxLSPH.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccjxLSPH.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccjxLSPH.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccjxLSPH.s:12     .text:0000000000000000 CreateList
     /tmp/ccjxLSPH.s:1359   .data:0000000000000004 servoStartAngle
     /tmp/ccjxLSPH.s:138    .text:0000000000000076 ArrangeAngle
                            *COM*:0000000000000002 servoSwitchPtr
                            *COM*:0000000000000002 servoSwitchPtrDup
     /tmp/ccjxLSPH.s:407    .text:00000000000001ac SendInteger
     /tmp/ccjxLSPH.s:441    .text:00000000000001c2 StringToInt
     /tmp/ccjxLSPH.s:488    .text:00000000000001e6 PrepareAddToList
     /tmp/ccjxLSPH.s:577    .text:0000000000000250 SendList
     /tmp/ccjxLSPH.s:649    .text:000000000000028c USARTInit
     /tmp/ccjxLSPH.s:1336   .data:0000000000000000 baudRate
     /tmp/ccjxLSPH.s:680    .text:00000000000002a8 TimerInit
     /tmp/ccjxLSPH.s:702    .text:00000000000002b6 ServoPortInit
     /tmp/ccjxLSPH.s:722    .text.startup:0000000000000000 main
     /tmp/ccjxLSPH.s:1343   .bss:0000000000000002 tempData
                            *COM*:0000000000000002 tempDataPtr
                            *COM*:0000000000000002 servoSwitchListPtr
                            *COM*:0000000000000002 tempServoHead
                            *COM*:0000000000000002 servoSwitch
                            *COM*:0000000000000002 servoSwitchDup
     /tmp/ccjxLSPH.s:1330   .bss:0000000000000000 arrangeSignalFlag
     /tmp/ccjxLSPH.s:1348   .bss:0000000000000008 count
     /tmp/ccjxLSPH.s:933    .text:00000000000002be __vector_6
     /tmp/ccjxLSPH.s:1251   .text:00000000000004c4 __vector_13
     /tmp/ccjxLSPH.s:1354   .data:0000000000000002 flag1
                            *COM*:0000000000000002 servoHead

UNDEFINED SYMBOLS
malloc
__floatunsisf
__mulsf3
__addsf3
__fixunssfsi
__subsf3
__do_copy_data
__do_clear_bss
